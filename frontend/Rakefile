require 'erb'
require 'json'
require 'thor/shell'
require 'pry'

$root_dir = __dir__
$stage = ENV.fetch('STAGE', 'dev')
$env_file = "../.env.#{$stage}.yml"
$app_name = "agrishot-#{$stage}"
$profile = "#{$app_name}-deploy"
$bucket_name = "#{$app_name}-web"
$table_name = "#{$app_name}-photos"
$identity_pool_name = $app_name.gsub(/-/, '_')
$authenticated_role_name = "#{$app_name}-AuthenticatedRole"
$dist_dir = 'dist'
$config_dir = 'config'
$wrk_dir = '.wrk'

Dir.chdir $root_dir

def aws cmd
  res = `aws --profile #{$profile} #{cmd}`
  unless $?.success?
    raise RuntimeError.new cmd
  end

  res
end

def env
  @env ||= YAML.load_file($env_file)
end

def say_status *args
  @shell ||= Thor::Base.shell.new
  @shell.say_status *args
end

def with_file file, delete_on_fail: false
  org = File.exists?(file) ? open(file, &:read) : nil
  cur = nil
  updated = false
  begin
    cur = yield
    lift =
      if File.extname(file) == '.json'
        ->(x) { x && JSON.load(x) }
      else
        ->(x) { x }
      end
    if lift.(org) != lift.(cur)
      open(file, 'w') { |io| io << cur }
      updated = true
    end
  rescue => err
    if delete_on_fail
      File.delete file if org
      cur = nil
    else
      raise err
    end
  end
  if org && cur
    if updated
      say_status :update, file, :blue
    else
      say_status :identical, file, :yellow
    end
  elsif org
    say_status :remove, file, :magenta
  elsif cur
    say_status :create, file, :green
  end
end


desc 'Display info'
task :info do
  puts "Root dir: #{$root_dir}"
  puts "Stage: #{$stage}"
  puts "App name: #{$app_name}"
  puts "Profile: #{$profile}"
  endpoint = "#{$wrk_dir}/s3/#{$bucket_name}/endpoint.txt"
  if File.exists? endpoint
    puts "Endpoint: #{File.read endpoint}"
  else
    puts "Endpoint: "
  end
end

desc 'Open browser'
task :browse do
  dst_dir = File.join($wrk_dir, 's3', $bucket_name)
  endpoint = File.join(dst_dir, 'endpoint.txt')
  unless File.exists? endpoint
    raise RuntimeError.new "#{endpoint} is not found"
  end
  sh "open #{File.read endpoint}"
end

desc 'Retrieve infomations from AWS'
task :pull => ['s3:pull', 'cognito:pull', 'dynamodb:pull']

namespace :s3 do
  dst_dir = File.join($wrk_dir, 's3', $bucket_name)
  endpoint = File.join(dst_dir, 'endpoint.txt')
  bucket_uri = "s3://#{$bucket_name}"

  file endpoint => :pull

  directory dst_dir

  desc 'Deploy public web to S3 bucket'
  task :deploy => [endpoint] do
    aws ['s3', 'sync',
         "#{$dist_dir}/", bucket_uri,
         '--acl', 'public-read'].join(' ')
  end

  task :pull => [dst_dir] do
    with_file endpoint, delete_on_fail: true do
      res = aws ['s3api', 'get-bucket-location',
                 '--bucket', $bucket_name].join(' ')
      info = JSON.load(res)
      region = info['LocationConstraint']
      "http://#{$bucket_name}.s3-website-#{region}.amazonaws.com"
    end
  end
end

namespace :cognito do
  dst_dir = File.join($wrk_dir, 'cognito/identity_pool', $identity_pool_name)
  identity_pool_config = File.join(dst_dir, 'identity_pool_config.json')
  identity_pool_info = File.join(dst_dir, 'identity_pool_info.json')
  assume_role_policy = File.join(dst_dir, 'assume_role_policy.json')
  assume_role_info = File.join(dst_dir, 'assume_role_info.json')

  src_of = ->(dst) { File.join($config_dir, dst.pathmap('%n.yml')) }

  directory dst_dir

  file identity_pool_config => [$env_file, dst_dir, src_of.(identity_pool_config)] do |t|
    src = t.prerequisites.last
    facebook_app_id = env['FACEBOOK_APP_ID']
    with_file t.name do
      res = ERB.new(open(src).read).result(binding)
      JSON.dump YAML.load(res)
    end
  end

  file identity_pool_info => [identity_pool_config] do |t|
    with_file t.name do
      aws ['cognito-identity',  'create-identity-pool',
           '--identity-pool-name', $identity_pool_name,
           '--cli-input-json', "file://#{identity_pool_config}"].join(' ')
    end
  end

  file assume_role_policy => [identity_pool_info, src_of.(assume_role_policy)] do |t|
    src = t.prerequisites.last
    info = JSON.load File.open(identity_pool_info)
    identity_pool_id = info['IdentityPoolId']
    with_file t.name do
      res = ERB.new(open(src).read).result(binding)
      JSON.dump YAML.load(res)
    end
  end

  file assume_role_info => [identity_pool_info, assume_role_policy] do |t|
    with_file t.name do
      aws ['iam', 'create-role',
           "--role-name", $authenticated_role_name,
           "--assume-role-policy-document", "file://#{assume_role_policy}"].join(' ')
    end
  end

  desc 'Create cognito identity pool'
  task :create => [identity_pool_info, assume_role_info] do |t|
    info = JSON.load File.open(identity_pool_info)
    identity_pool_id = info['IdentityPoolId']
    role_info = JSON.load File.open(assume_role_info)
    role_arn = role_info['Role']['Arn']
    aws ['cognito-identity', 'set-identity-pool-roles',
         '--identity-pool-id', identity_pool_id,
         '--roles', "authenticated=#{role_arn}"].join(' ')
  end

  task :pull do
    res = aws ['cognito-identity', 'list-identity-pools',
               '--max-results', '60'].join(' ')
    list = JSON.parse res
    identity_pool_id = list['IdentityPools']
                         .find { |x| x['IdentityPoolName'] == $identity_pool_name }
                         .to_h['IdentityPoolId']

    with_file identity_pool_info, delete_on_fail: true do
      aws ['cognito-identity', 'describe-identity-pool',
           '--identity-pool-id', identity_pool_id].join(' ')
    end

    with_file assume_role_info, delete_on_fail: true do
      aws ['iam', 'get-role',
           "--role-name", $authenticated_role_name].join(' ')
    end
  end
end

namespace :dynamodb do
  dst_dir = File.join($wrk_dir, 'dynamodb', $table_name)
  table_info = File.join(dst_dir, 'table_info.json')
  table_role_policy = File.join(dst_dir, 'table_role_policy.json')
  table_role_info = File.join(dst_dir, 'table_role_info.json')

  src_of = ->(dst) { File.join($config_dir, dst.pathmap('%n.yml')) }

  file table_role_policy => [table_info, src_of.(table_role_policy)] do |t|
    src = t.prerequisites.last
    info = JSON.load File.open(table_info)
    table_arn = info['Table']['TableArn']
    with_file t.name do
      res = ERB.new(open(src).read).result(binding)
      JSON.dump YAML.load(res)
    end
  end

  file table_role_info => [table_role_policy] do |t|
    policy_name = "#{$table_name}_table_access"
    with_file t.name do
      aws ['iam', 'put-role-policy',
           '--role-name', $authenticated_role_name,
           '--policy-name', policy_name,
           '--policy-document', "file://#{table_role_policy}"].join(' ')
      aws ['iam', 'get-role-policy',
           '--role-name', $authenticated_role_name,
           '--policy-name', policy_name].join(' ')
    end
  end

  task :put_role_policy => [table_role_info]

  task :pull do
    with_file table_info, delete_on_fail: true do
      aws ['dynamodb', 'describe-table',
           '--table-name', $table_name].join(' ')
    end

    with_file table_role_info, delete_on_fail: true do
      policy_name = "#{$table_name}_table_access"
      aws ['iam', 'get-role-policy',
           '--role-name', $authenticated_role_name,
           '--policy-name', policy_name].join(' ')
    end
  end
end
